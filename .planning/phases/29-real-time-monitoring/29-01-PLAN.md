---
phase: 29-real-time-monitoring
plan: 01
type: execute
depends_on: ["28-01"]
files_modified: [src/reddit_insight/streaming/monitor.py, src/reddit_insight/dashboard/routers/live.py, src/reddit_insight/dashboard/templates/live/index.html]
---

<objective>
실시간 모니터링 기능을 구현한다: WebSocket/SSE 기반 라이브 대시보드.

Purpose: 서브레딧 활동의 실시간 추적으로 즉각적인 트렌드 파악
Output: SubredditMonitor, 라이브 대시보드, SSE 스트림
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/reddit_insight/collectors/reddit_client.py

**실시간 모니터링 요구사항:**
- 새 게시물 실시간 수집
- 활동량 변화 추적
- 키워드 급등 감지
- Server-Sent Events (SSE) 사용 (WebSocket보다 단순)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Subreddit Monitor</name>
  <files>src/reddit_insight/streaming/__init__.py, src/reddit_insight/streaming/monitor.py</files>
  <action>서브레딧 실시간 모니터를 구현한다:

  ```python
  @dataclass
  class LiveUpdate:
      type: str  # "new_post", "activity_spike", "keyword_surge"
      timestamp: datetime
      data: dict

  class SubredditMonitor:
      def __init__(self, subreddit: str, client: RedditClient, interval: int = 30):
          self.subreddit = subreddit
          self.client = client
          self.interval = interval
          self._running = False
          self._last_post_id: str | None = None
          self._subscribers: list[asyncio.Queue] = []

      async def start(self) -> None:
          """모니터링 시작 (백그라운드 태스크)"""
          self._running = True
          while self._running:
              updates = await self._check_updates()
              for update in updates:
                  await self._broadcast(update)
              await asyncio.sleep(self.interval)

      async def stop(self) -> None:
          """모니터링 중지"""
          self._running = False

      async def subscribe(self) -> asyncio.Queue:
          """업데이트 구독 (SSE 클라이언트용)"""
          queue = asyncio.Queue()
          self._subscribers.append(queue)
          return queue

      async def _check_updates(self) -> list[LiveUpdate]:
          """새 게시물 및 활동 변화 확인"""

      async def _broadcast(self, update: LiveUpdate) -> None:
          """모든 구독자에게 업데이트 전송"""
  ```</action>
  <verify>pytest tests/streaming/test_monitor.py -v</verify>
  <done>SubredditMonitor 구현 완료</done>
</task>

<task type="auto">
  <name>Task 2: Create SSE Streaming Endpoint</name>
  <files>src/reddit_insight/dashboard/routers/live.py, src/reddit_insight/dashboard/services/live_service.py</files>
  <action>Server-Sent Events 스트리밍 엔드포인트를 구현한다:

  ```python
  # live_service.py
  class LiveService:
      def __init__(self):
          self._monitors: dict[str, SubredditMonitor] = {}

      async def start_monitoring(self, subreddit: str) -> SubredditMonitor:
          """서브레딧 모니터링 시작 (이미 있으면 기존 반환)"""

      async def stop_monitoring(self, subreddit: str) -> None:
          """서브레딧 모니터링 중지"""

      def get_active_monitors(self) -> list[str]:
          """활성 모니터 목록"""

  # live.py
  @router.get("/dashboard/live")
  async def live_dashboard(request: Request):
      """라이브 대시보드 페이지"""

  @router.get("/dashboard/live/stream/{subreddit}")
  async def live_stream(subreddit: str):
      """SSE 스트림 엔드포인트"""
      async def event_generator():
          monitor = await live_service.start_monitoring(subreddit)
          queue = await monitor.subscribe()
          try:
              while True:
                  update = await queue.get()
                  yield f"data: {json.dumps(update.to_dict())}\n\n"
          except asyncio.CancelledError:
              pass

      return StreamingResponse(
          event_generator(),
          media_type="text/event-stream"
      )

  @router.post("/dashboard/live/start/{subreddit}")
  async def start_monitoring(subreddit: str):
      """모니터링 시작"""

  @router.post("/dashboard/live/stop/{subreddit}")
  async def stop_monitoring(subreddit: str):
      """모니터링 중지"""
  ```</action>
  <verify>curl -N http://localhost:8888/dashboard/live/stream/claude 로 SSE 스트림 확인</verify>
  <done>SSE 스트리밍 엔드포인트 구현 완료</done>
</task>

<task type="auto">
  <name>Task 3: Build Live Dashboard UI</name>
  <files>src/reddit_insight/dashboard/templates/live/index.html, src/reddit_insight/dashboard/static/js/live-dashboard.js</files>
  <action>라이브 대시보드 UI를 구현한다:

  1. 라이브 대시보드 페이지 (live/index.html):
     - 서브레딧 선택 및 모니터링 시작/중지
     - 실시간 피드 (새 게시물)
     - 활동량 실시간 차트 (라인 차트, 스크롤링)
     - 키워드 급등 알림 배너

  2. JavaScript SSE 클라이언트 (live-dashboard.js):
     ```javascript
     class LiveDashboard {
       constructor(subreddit) {
         this.subreddit = subreddit;
         this.eventSource = null;
       }

       connect() {
         this.eventSource = new EventSource(
           `/dashboard/live/stream/${this.subreddit}`
         );
         this.eventSource.onmessage = (event) => {
           const update = JSON.parse(event.data);
           this.handleUpdate(update);
         };
         this.eventSource.onerror = () => {
           this.reconnect();
         };
       }

       handleUpdate(update) {
         if (update.type === 'new_post') {
           this.addPostToFeed(update.data);
         } else if (update.type === 'activity_spike') {
           this.showActivitySpike(update.data);
         }
         this.updateChart(update);
       }
     }
     ```

  3. 네비게이션에 "Live" 메뉴 추가</action>
  <verify>브라우저에서 /dashboard/live 작동 확인, 실시간 업데이트 표시</verify>
  <done>라이브 대시보드 UI 구현 완료</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] SubredditMonitor 단위 테스트 통과
- [ ] SSE 스트림 작동 확인
- [ ] 라이브 대시보드 UI 작동
- [ ] 연결 끊김 시 자동 재연결
</verification>

<success_criteria>

- SubredditMonitor: 폴링 기반 실시간 모니터링
- SSE 스트리밍 엔드포인트
- 라이브 대시보드: 실시간 피드, 차트
- 자동 재연결 메커니즘
</success_criteria>

<output>
After completion, create `.planning/phases/29-real-time-monitoring/29-01-SUMMARY.md`
</output>
